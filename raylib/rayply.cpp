// Copyright (c) 2020
// Commonwealth Scientific and Industrial Research Organisation (CSIRO)
// ABN 41 687 119 230
//
// Author: Thomas Lowe
#include "rayply.h"
#include "raylib/rayprogress.h"
#include "raylib/rayprogressthread.h"
#include "raymesh.h"

#include <fstream>
#include <iostream>
#include <vector> // For dynamic buffer

namespace ray
{
namespace
{
// these are set once and are constant after that
unsigned long chunk_header_length = 0;
unsigned long point_cloud_chunk_header_length = 0;
unsigned long vertex_size_pos = 0;
unsigned long point_cloud_vertex_size_pos = 0;

enum DataType
{
  kDTfloat,
  kDTdouble,
  kDTushort,
  kDTuchar,
  kDTint,
  kDTnone
};
}  // namespace

// --- START OF MODIFICATION: Flexible PLY Writer ---
bool writeRayCloudChunkStart(const std::string &file_name, std::ofstream &out, bool has_classification, bool has_branch_id)
{
  int num_zeros = std::numeric_limits<unsigned long>::digits10;
  out.open(file_name, std::ios::binary | std::ios::out);
  if (out.fail())
  {
    std::cerr << "Error: cannot open " << file_name << " for writing." << std::endl;
    return false;
  }
  out << "ply" << std::endl;
  out << "format binary_little_endian 1.0" << std::endl;
  out << "comment generated by raycloudtools library" << std::endl;
  out << "element vertex ";
  for (int i = 0; i < num_zeros; i++)
    out << "0";
  vertex_size_pos = out.tellp();
  out << std::endl;
#if RAYLIB_DOUBLE_RAYS
  out << "property double x" << std::endl;
  out << "property double y" << std::endl;
  out << "property double z" << std::endl;
#else
  out << "property float x" << std::endl;
  out << "property float y" << std::endl;
  out << "property float z" << std::endl;
#endif
  out << "property double time" << std::endl;
  // --- START OF FIX: Reverted property names to original nx, ny, nz ---
  out << "property float nx" << std::endl;
  out << "property float ny" << std::endl;
  out << "property float nz" << std::endl;
  // --- END OF FIX ---
  out << "property uchar red" << std::endl;
  out << "property uchar green" << std::endl;
  out << "property uchar blue" << std::endl;
  out << "property uchar alpha" << std::endl;
  if (has_classification) {
    out << "property uchar classification" << std::endl;
  }
  if (has_branch_id) {
    out << "property ushort branch_id" << std::endl;
  }
  out << "end_header" << std::endl;
  chunk_header_length = out.tellp();
  return true;
}

bool writeRayCloudChunk(std::ofstream &out, std::vector<char>& buffer,
                        const std::vector<Eigen::Vector3d> &starts,
                        const std::vector<Eigen::Vector3d> &ends, const std::vector<double> &times,
                        const std::vector<RGBA> &colours, 
                        const std::vector<uint8_t> &classifications,
                        const std::vector<uint16_t> &branch_ids,
                        bool &has_warned)
{
  if (ends.empty())
  {
    return true;
  }
  if (out.tellp() < (long)chunk_header_length)
  {
    std::cerr << "Error: file header has not been written, use writeRayCloudChunkStart" << std::endl;
    return false;
  }

  bool has_classification = !classifications.empty();
  bool has_branch_id = !branch_ids.empty();

  size_t vertex_byte_size = 0;
#if RAYLIB_DOUBLE_RAYS
  vertex_byte_size += sizeof(double) * 3;
#else
  vertex_byte_size += sizeof(float) * 3;
#endif
  vertex_byte_size += sizeof(double); // time
  vertex_byte_size += sizeof(float) * 3; // nx, ny, nz vector
  vertex_byte_size += sizeof(RGBA);
  if (has_classification) vertex_byte_size += sizeof(uint8_t);
  if (has_branch_id) vertex_byte_size += sizeof(uint16_t);

  buffer.resize(ends.size() * vertex_byte_size);
  char* current_pos = buffer.data();

  for (size_t i = 0; i < ends.size(); i++)
  {
#if RAYLIB_DOUBLE_RAYS
    memcpy(current_pos, &ends[i], sizeof(double) * 3); current_pos += sizeof(double) * 3;
#else
    Eigen::Vector3f endf = ends[i].cast<float>();
    memcpy(current_pos, &endf, sizeof(float) * 3); current_pos += sizeof(float) * 3;
#endif
    memcpy(current_pos, &times[i], sizeof(double)); current_pos += sizeof(double);
    Eigen::Vector3f n = (starts[i] - ends[i]).cast<float>(); // The data being written (start - end vector) is correct
    memcpy(current_pos, &n, sizeof(float) * 3); current_pos += sizeof(float) * 3;
    memcpy(current_pos, &colours[i], sizeof(RGBA)); current_pos += sizeof(RGBA);
    if (has_classification) {
      memcpy(current_pos, &classifications[i], sizeof(uint8_t)); current_pos += sizeof(uint8_t);
    }
    if (has_branch_id) {
      memcpy(current_pos, &branch_ids[i], sizeof(uint16_t)); current_pos += sizeof(uint16_t);
    }
  }
  out.write(buffer.data(), buffer.size());
  if (!out.good())
  {
    std::cerr << "error writing to file" << std::endl;
    return false;
  }
  return true;
}

unsigned long writeRayCloudChunkEnd(std::ofstream &out, size_t vertex_byte_size)
{
  const unsigned long size = static_cast<unsigned long>(out.tellp()) - chunk_header_length;
  if (vertex_byte_size == 0) return 0;
  const unsigned long number_of_rays = size / vertex_byte_size;
  std::stringstream stream;
  stream << number_of_rays;
  std::string str = stream.str();
  out.seekp(vertex_size_pos - str.length());
  out << str;
  return number_of_rays;
}

bool writePlyRayCloud(const std::string &file_name, const std::vector<Eigen::Vector3d> &starts,
                      const std::vector<Eigen::Vector3d> &ends, const std::vector<double> &times,
                      const std::vector<RGBA> &colours,
                      const std::vector<uint8_t> &classifications,
                      const std::vector<uint16_t> &branch_ids,
                      bool write_extra_fields)
{
  std::ofstream ofs;
  bool has_classification = write_extra_fields && !classifications.empty();
  bool has_branch_id = write_extra_fields && !branch_ids.empty();

  if (!writeRayCloudChunkStart(file_name, ofs, has_classification, has_branch_id))
    return false;

  size_t vertex_byte_size = 0;
#if RAYLIB_DOUBLE_RAYS
  vertex_byte_size += sizeof(double) * 3;
#else
  vertex_byte_size += sizeof(float) * 3;
#endif
  vertex_byte_size += sizeof(double); // time
  vertex_byte_size += sizeof(float) * 3; // ray vector
  vertex_byte_size += sizeof(RGBA);
  if (has_classification) vertex_byte_size += sizeof(uint8_t);
  if (has_branch_id) vertex_byte_size += sizeof(uint16_t);

  std::vector<char> buffer;
  bool has_warned = false;
  
  if (!writeRayCloudChunk(ofs, buffer, starts, ends, times, colours, classifications, branch_ids, has_warned))
  {
    return false;
  }
  const unsigned long num_rays = writeRayCloudChunkEnd(ofs, vertex_byte_size);
  std::cout << num_rays << " rays saved to " << file_name << std::endl;
  return true;
}

// Point cloud chunked writing
bool writePointCloudChunkStart(const std::string &file_name, std::ofstream &out, bool has_classification, bool has_point_source_id)
{
    int num_zeros = std::numeric_limits<unsigned long>::digits10;
    std::cout << "saving to " << file_name << " ..." << std::endl;
    out.open(file_name, std::ios::binary | std::ios::out);
    if (out.fail())
    {
        std::cerr << "Error: cannot open " << file_name << " for writing." << std::endl;
        return false;
    }
    out << "ply" << std::endl;
    out << "format binary_little_endian 1.0" << std::endl;
    out << "comment generated by raycloudtools library" << std::endl;
    out << "element vertex ";
    for (int i = 0; i < num_zeros; i++)
        out << "0";
    point_cloud_vertex_size_pos = out.tellp();
    out << std::endl;
#if RAYLIB_DOUBLE_RAYS
    out << "property double x" << std::endl;
    out << "property double y" << std::endl;
    out << "property double z" << std::endl;
#else
    out << "property float x" << std::endl;
    out << "property float y" << std::endl;
    out << "property float z" << std::endl;
#endif
    out << "property double time" << std::endl;
    out << "property uchar red" << std::endl;
    out << "property uchar green" << std::endl;
    out << "property uchar blue" << std::endl;
    out << "property uchar alpha" << std::endl;
    if (has_classification) {
        out << "property uchar classification" << std::endl;
    }
    if (has_point_source_id) {
        out << "property ushort PointSourceID" << std::endl;
    }
    out << "end_header" << std::endl;
    point_cloud_chunk_header_length = out.tellp();
    return true;
}

bool writePointCloudChunk(std::ofstream &out, std::vector<char>& buffer, const std::vector<Eigen::Vector3d> &points,
                          const std::vector<double> &times, const std::vector<RGBA> &colours,
                          const std::vector<uint8_t> &classifications,
                          const std::vector<uint16_t> &point_source_ids,
                          bool &has_warned)
{
    if (points.empty())
    {
        return true;
    }
    if (out.tellp() < (long)point_cloud_chunk_header_length)
    {
        std::cerr << "Error: file header has not been written, use writePointCloudChunkStart" << std::endl;
        return false;
    }

    bool has_classification = !classifications.empty();
    bool has_point_source_id = !point_source_ids.empty();
    
    size_t vertex_byte_size = 0;
#if RAYLIB_DOUBLE_RAYS
    vertex_byte_size += sizeof(double) * 3;
#else
    vertex_byte_size += sizeof(float) * 3;
#endif
    vertex_byte_size += sizeof(double); // time
    vertex_byte_size += sizeof(RGBA);
    if (has_classification) vertex_byte_size += sizeof(uint8_t);
    if (has_point_source_id) vertex_byte_size += sizeof(uint16_t);

    buffer.resize(points.size() * vertex_byte_size);
    char* current_pos = buffer.data();
    
    for (size_t i = 0; i < points.size(); i++)
    {
#if RAYLIB_DOUBLE_RAYS
        memcpy(current_pos, &points[i], sizeof(double) * 3); current_pos += sizeof(double) * 3;
#else
        Eigen::Vector3f p_float = points[i].cast<float>();
        memcpy(current_pos, &p_float, sizeof(float) * 3); current_pos += sizeof(float) * 3;
#endif
        memcpy(current_pos, &times[i], sizeof(double)); current_pos += sizeof(double);
        memcpy(current_pos, &colours[i], sizeof(RGBA)); current_pos += sizeof(RGBA);
        if (has_classification) {
            memcpy(current_pos, &classifications[i], sizeof(uint8_t)); current_pos += sizeof(uint8_t);
        }
        if (has_point_source_id) {
            memcpy(current_pos, &point_source_ids[i], sizeof(uint16_t)); current_pos += sizeof(uint16_t);
        }
    }
    
    out.write(buffer.data(), buffer.size());
    if (!out.good())
    {
        std::cerr << "error writing to file" << std::endl;
        return false;
    }
    return true;
}

void writePointCloudChunkEnd(std::ofstream &out, size_t vertex_byte_size)
{
    const unsigned long size = static_cast<unsigned long>(out.tellp()) - point_cloud_chunk_header_length;
    if (vertex_byte_size == 0) return;
    const unsigned long number_of_points = size / vertex_byte_size;
    std::stringstream stream;
    stream << number_of_points;
    std::string str = stream.str();
    out.seekp(point_cloud_vertex_size_pos - str.length());
    out << str;
    std::cout << "... saved out " << number_of_points << " points." << std::endl;
}

bool writePlyPointCloud(const std::string &file_name, const std::vector<Eigen::Vector3d> &points,
                        const std::vector<double> &times, const std::vector<RGBA> &colours,
                        const std::vector<uint8_t> &classifications,
                        const std::vector<uint16_t> &point_source_ids,
                        bool write_extra_fields)
{
    std::ofstream ofs;
    bool has_classification = write_extra_fields && !classifications.empty();
    bool has_point_source_id = write_extra_fields && !point_source_ids.empty();

    if (!writePointCloudChunkStart(file_name, ofs, has_classification, has_point_source_id))
        return false;
        
    size_t vertex_byte_size = 0;
#if RAYLIB_DOUBLE_RAYS
    vertex_byte_size += sizeof(double) * 3;
#else
    vertex_byte_size += sizeof(float) * 3;
#endif
    vertex_byte_size += sizeof(double); // time
    vertex_byte_size += sizeof(RGBA);
    if (has_classification) vertex_byte_size += sizeof(uint8_t);
    if (has_point_source_id) vertex_byte_size += sizeof(uint16_t);

    std::vector<char> buffer;
    bool has_warned = false;
    if (!writePointCloudChunk(ofs, buffer, points, times, colours, classifications, point_source_ids, has_warned))
    {
        return false;
    }
    writePointCloudChunkEnd(ofs, vertex_byte_size);
    return true;
}
// --- END OF MODIFICATION ---

// --- START OF MODIFICATION: Flexible PLY Reader ---
bool readPly(const std::string &file_name, bool is_ray_cloud,
             std::function<void(std::vector<Eigen::Vector3d> &starts, std::vector<Eigen::Vector3d> &ends,
                                std::vector<double> &times, std::vector<RGBA> &colours,
                                std::vector<uint8_t> &classifications, std::vector<uint16_t> &branch_ids)>
               apply, 
             double max_intensity, bool times_optional, size_t chunk_size)
{
  std::cout << "reading: " << file_name << std::endl;
  std::ifstream input(file_name.c_str(), std::ios::in | std::ios::binary);
  if (input.fail())
  {
    std::cerr << "Couldn't open file: " << file_name << std::endl;
    return false;
  }
  std::string line;
  int row_size = 0;
  int offset = -1, normal_offset = -1, time_offset = -1, colour_offset = -1;
  int intensity_offset = -1;
  int classification_offset = -1;
  int branch_id_offset = -1;
  
  bool time_is_float = false;
  bool pos_is_float = false;
  bool normal_is_float = false;
  DataType intensity_type = kDTnone;
  int rowsteps[] = { int(sizeof(float)), int(sizeof(double)), int(sizeof(unsigned short)), int(sizeof(unsigned char)), int(sizeof(int)), 0 };

  while (line != "end_header\r" && line != "end_header")
  {
    if (!getline(input, line)) break;
    if (line.find("format ascii 1.0") != std::string::npos) { std::cerr << "ASCII PLY not supported " << file_name << std::endl; return false; }

    DataType data_type = kDTnone;
    if (line.find("property float") != std::string::npos) data_type = kDTfloat;
    else if (line.find("property double") != std::string::npos) data_type = kDTdouble;
    else if (line.find("property uchar") != std::string::npos || line.find("property uint8") != std::string::npos) data_type = kDTuchar;
    else if (line.find("property ushort") != std::string::npos) data_type = kDTushort;
    else if (line.find("property int") != std::string::npos) data_type = kDTint;

    if (line.find("property float x") != std::string::npos || line.find("property double x") != std::string::npos) { offset = row_size; pos_is_float = (line.find("float") != std::string::npos); }
    // --- START OF FIX: Reverted to looking for original nx, ny, nz properties ---
    if (line.find("property float nx") != std::string::npos || line.find("property double nx") != std::string::npos) { normal_offset = row_size; normal_is_float = (line.find("float") != std::string::npos); }
    // --- END OF FIX ---
    if (line.find("time") != std::string::npos) { time_offset = row_size; time_is_float = (line.find("float") != std::string::npos); }
    if (line.find("intensity") != std::string::npos) { intensity_offset = row_size; intensity_type = data_type; }
    if (line.find("property uchar red") != std::string::npos || line.find("property uint8 red") != std::string::npos) colour_offset = row_size;
    if (line.find("classification") != std::string::npos) classification_offset = row_size;
    if (line.find("branch_id") != std::string::npos || line.find("PointSourceID") != std::string::npos) branch_id_offset = row_size;
    
    row_size += rowsteps[data_type];
  }

  if (offset == -1) { std::cerr << "could not find position properties of file: " << file_name << std::endl; return false; }
  if (is_ray_cloud && normal_offset == -1) { std::cerr << "could not find ray properties (nx, ny, nz) of file: " << file_name << std::endl; return false; }
  
  std::streampos start = input.tellg();
  input.seekg(0, input.end);
  size_t length = input.tellg() - start;
  input.seekg(start);
  size_t size = (row_size > 0) ? length / row_size : 0;
  
  std::vector<char> vertex_buffer(row_size);
    // pre-reserving avoids memory fragmentation
  std::vector<Eigen::Vector3d> ends, starts;
  std::vector<double> times;
  std::vector<ray::RGBA> colours;
  std::vector<uint8_t> classifications;
  std::vector<uint16_t> branch_ids;

  size_t reserve_size = std::min(chunk_size, size);
  ends.reserve(reserve_size);
  starts.reserve(reserve_size);
  times.reserve(reserve_size);
  colours.reserve(reserve_size);
  if (classification_offset != -1) classifications.reserve(reserve_size);
  if (branch_id_offset != -1) branch_ids.reserve(reserve_size);
  
  for (size_t i = 0; i < size; i++)
  {
    input.read(vertex_buffer.data(), row_size);
    Eigen::Vector3d end;
    // --- START OF FIX: Replaced unsafe memcpy with Eigen::Map for memory safety ---
    // This safely interprets the buffer memory as an Eigen type, respecting alignment.
    if (pos_is_float) { 
        end = Eigen::Map<const Eigen::Vector3f>(reinterpret_cast<const float*>(&vertex_buffer[offset])).cast<double>();
    } else { 
        end = Eigen::Map<const Eigen::Vector3d>(reinterpret_cast<const double*>(&vertex_buffer[offset]));
    }
    
    Eigen::Vector3d normal(0, 0, 0);
    if (normal_offset != -1) {
        if (normal_is_float) { 
            normal = Eigen::Map<const Eigen::Vector3f>(reinterpret_cast<const float*>(&vertex_buffer[normal_offset])).cast<double>();
        } else { 
            normal = Eigen::Map<const Eigen::Vector3d>(reinterpret_cast<const double*>(&vertex_buffer[normal_offset]));
        }
    }
    
    starts.push_back(end + normal); // Reconstruct start point: end + (start - end) = start
    ends.push_back(end);
    
    if (time_offset != -1) {
        double time = 0;
        if (time_is_float) { 
            time = static_cast<double>(*reinterpret_cast<const float*>(&vertex_buffer[time_offset]));
        } else { 
            time = *reinterpret_cast<const double*>(&vertex_buffer[time_offset]);
        }
        times.push_back(time);
    }
    
    if (colour_offset != -1) {
        colours.push_back(*reinterpret_cast<const RGBA*>(&vertex_buffer[colour_offset]));
    }

    if (classification_offset != -1) {
        classifications.push_back(*reinterpret_cast<const uint8_t*>(&vertex_buffer[classification_offset]));
    }

    if (branch_id_offset != -1) {
        branch_ids.push_back(*reinterpret_cast<const uint16_t*>(&vertex_buffer[branch_id_offset]));
    }
    // --- END OF FIX ---
    
    if (ends.size() == chunk_size || i == size - 1)
    {
      if (colour_offset == -1) colourByTime(times, colours);
      if (classification_offset == -1) classifications.assign(ends.size(), 0);
      if (branch_id_offset == -1) branch_ids.assign(ends.size(), 0);

      apply(starts, ends, times, colours, classifications, branch_ids);
      starts.clear(); ends.clear(); times.clear(); colours.clear();
      classifications.clear(); branch_ids.clear();
    }
  }

  return true;
}

bool readPly(const std::string &file_name, std::vector<Eigen::Vector3d> &starts, std::vector<Eigen::Vector3d> &ends,
             std::vector<double> &times, std::vector<RGBA> &colours,
             std::vector<uint8_t> &classifications, std::vector<uint16_t> &branch_ids,
             bool is_ray_cloud, double max_intensity)
{
  auto apply = [&](std::vector<Eigen::Vector3d> &s, std::vector<Eigen::Vector3d> &e,
                   std::vector<double> &t, std::vector<RGBA> &c,
                   std::vector<uint8_t> &cls, std::vector<uint16_t> &bids) 
  {
    starts.insert(starts.end(), s.begin(), s.end());
    ends.insert(ends.end(), e.begin(), e.end());
    times.insert(times.end(), t.begin(), t.end());
    colours.insert(colours.end(), c.begin(), c.end());
    classifications.insert(classifications.end(), cls.begin(), cls.end());
    branch_ids.insert(branch_ids.end(), bids.begin(), bids.end());
  };
  return readPly(file_name, is_ray_cloud, apply, max_intensity, false, std::numeric_limits<size_t>::max());
}

bool readPly(const std::string &file_name, std::vector<Eigen::Vector3d> &starts, std::vector<Eigen::Vector3d> &ends,
             std::vector<double> &times, std::vector<RGBA> &colours, bool is_ray_cloud, double max_intensity)
{
    std::vector<uint8_t> dummy_cls;
    std::vector<uint16_t> dummy_bids;
    return readPly(file_name, starts, ends, times, colours, dummy_cls, dummy_bids, is_ray_cloud, max_intensity);
}
// --- END OF MODIFICATION ---

bool writePlyMesh(const std::string &file_name, const Mesh &mesh, bool flip_normals)
{
  std::cout << "saving to " << file_name << ", " << mesh.vertices().size() << " vertices." << std::endl;
  if (mesh.indexList().size() == 0 || mesh.vertices().size() < 3)
  {
    std::cout << "Warning: mesh is empty or too small to save. Num vertices: " << mesh.vertices().size() << std::endl;
    return false;
  }

#if RAYLIB_DOUBLE_RAYS
  int row_size = 28;
  struct Vert
  {
    Eigen::Vector3d pos;
    ray::RGBA colour;
  };
#else 
  int row_size = 16;
  struct Vert
  {
    Eigen::Vector3f pos;
    ray::RGBA colour;
  };
#endif 
  std::vector<unsigned char> vertices(row_size * mesh.vertices().size());  // 4d to give space for colour
  for (size_t i = 0; i < mesh.vertices().size(); i++)
  {
    Vert vert;
#if RAYLIB_DOUBLE_RAYS
    vert.pos = mesh.vertices()[i];
#else
    vert.pos = mesh.vertices()[i].cast<float>();
#endif
    vert.colour = mesh.colours().empty() ? ray::RGBA(127,127,127,255) : mesh.colours()[i];
    memcpy(&vertices[row_size * i], &vert, row_size);
  }

  FILE *fid = fopen(file_name.c_str(), "w+");
  if (!fid)
  {
    std::cerr << "error opening file " << file_name << " for writing." << std::endl;
    return false;
  }
  fprintf(fid, "ply\n");
  fprintf(fid, "format binary_little_endian 1.0\n");
  fprintf(fid, "comment SDK generated\n");  // TODO: add version here
  if (!mesh.uvList().empty())
  {
    std::string tex_name = mesh.textureName() == "" ? "wood_texture.png" : mesh.textureName();
    fprintf(fid, "comment TextureFile %s\n", tex_name.c_str()); 
  }
  fprintf(fid, "element vertex %u\n", unsigned(mesh.vertices().size()));
#if RAYLIB_DOUBLE_RAYS
  fprintf(fid, "property double x\n");
  fprintf(fid, "property double y\n");
  fprintf(fid, "property double z\n");
#else
  fprintf(fid, "property float x\n");
  fprintf(fid, "property float y\n");
  fprintf(fid, "property float z\n");
#endif
  fprintf(fid, "property uchar red\n");
  fprintf(fid, "property uchar green\n");
  fprintf(fid, "property uchar blue\n");
  fprintf(fid, "property uchar alpha\n");
  fprintf(fid, "element face %u\n", (unsigned)mesh.indexList().size());
  fprintf(fid, "property list int int vertex_indices\n");
  if (!mesh.uvList().empty())
  {
    fprintf(fid, "property list int float texcoord\n");
    fprintf(fid, "property int texnumber\n");
  }
  fprintf(fid, "end_header\n");

  fwrite(&vertices[0], sizeof(unsigned char), vertices.size(), fid);

  auto &list = mesh.indexList();
  size_t written;
  if (mesh.uvList().empty())
  {
    std::vector<Eigen::Vector4i> triangles(mesh.indexList().size());
    if (flip_normals)
      for (size_t i = 0; i < list.size(); i++) triangles[i] = Eigen::Vector4i(3, list[i][2], list[i][1], list[i][0]);
    else
      for (size_t i = 0; i < list.size(); i++) triangles[i] = Eigen::Vector4i(3, list[i][0], list[i][1], list[i][2]);
    written = fwrite(&triangles[0], sizeof(Eigen::Vector4i), triangles.size(), fid);
  }
  else
  {
    struct Face
    {
      int num_corners;
      Eigen::Vector3i ids;
      int num_coords;
      float uvs[6];
      int texnumber;
    };
    auto &uvs = mesh.uvList();
    std::vector<Face> faces(uvs.size());
    for (size_t i = 0; i < list.size(); i++) 
    {
      faces[i].num_corners = 3;
      if (flip_normals)
        faces[i].ids = Eigen::Vector3i(list[i][2], list[i][1], list[i][0]);
      else
        faces[i].ids = Eigen::Vector3i(list[i][0], list[i][1], list[i][2]);
      
      faces[i].num_coords = 6;
      faces[i].uvs[0] = uvs[i][0].real();
      faces[i].uvs[1] = uvs[i][0].imag();
      faces[i].uvs[2] = uvs[i][1].real();
      faces[i].uvs[3] = uvs[i][1].imag();
      faces[i].uvs[4] = uvs[i][2].real();
      faces[i].uvs[5] = uvs[i][2].imag();
      faces[i].texnumber = 0;
    }
    written = fwrite(&faces[0], sizeof(Face), faces.size(), fid);
  }

  fclose(fid);
  if (written == 0)
  {
    std::cerr << "Error writing to file " << file_name << std::endl;
    return false;
  }

#if defined OUTPUT_MOMENTS // Only used to supply data to unit tests
  Eigen::Array<double, 6, 1> mom = mesh.getMoments();
  std::cout << "stats: " << std::endl;
  for (int i = 0; i < mom.rows(); i++) 
  { 
    std::cout << ", " << mom[i];
  }
  std::cout << std::endl;
#endif  // defined OUTPUT_MOMENTS
  return true;
}

bool readPlyMesh(const std::string &file, Mesh &mesh)
{
  std::ifstream input(file.c_str(), std::ios::in | std::ios::binary);
  if (input.fail())
  {
    std::cerr << "Couldn't open file: " << file << std::endl;
    return false;
  }
  std::string line;
  unsigned row_size = 0;
  unsigned number_of_faces = 0;
  unsigned number_of_vertices = 0;
  char char1[100], char2[100], char3[100], char4[100], char5[100];
  int pos_offset = -1;
  bool pos_is_float = false;
  int order_size = 0;
  int vertex_index_size = 0;
  int uv_order_size = 0;
  int uv_size = 0;
  int texnumber_size = 0;
  while (line != "end_header\r" && line != "end_header")
  {
    if (!getline(input, line))
    {
      break;
    }
    if (line.find("format ascii") != std::string::npos)
    {
      std::cerr << "error: can only read in binary ply mesh files" << std::endl;
      return false;
    }
    if (line.find("property float x") != std::string::npos)
    {
      pos_offset = row_size;
      pos_is_float = true;
    }
    if (line.find("property double x") != std::string::npos)
    {
      pos_offset = row_size;
    }
    if (line.find("property float") != std::string::npos)
      row_size += int(sizeof(float));
    else if (line.find("property double") != std::string::npos)
      row_size += int(sizeof(double));
    else if (line.find("property uchar") != std::string::npos || line.find("property uint8") != std::string::npos)
      row_size += int(sizeof(unsigned char));
    else if (line.find("property ushort") != std::string::npos)
      row_size += int(sizeof(unsigned short));

    if (line.find("element vertex") != std::string::npos)
    {
      sscanf(line.c_str(), "%s %s %u", char1, char2, &number_of_vertices);
    }
    if (line.find("element face") != std::string::npos)
    {
      sscanf(line.c_str(), "%s %s %u", char1, char2, &number_of_faces);
    }
    if (line.find("property list") != std::string::npos && line.find("vertex_indices") != std::string::npos)
    {
      sscanf(line.c_str(), "%s %s %s %s %s", char1, char2, char3, char4, char5);
      std::string type1(char3);
      std::string type2(char4);
      order_size        = type1 == "uchar" ? int(sizeof(unsigned char)) : (type1 == "ushort" ? int(sizeof(unsigned short)) : int(sizeof(int)));
      vertex_index_size = type2 == "uchar" ? int(sizeof(unsigned char)) : (type2 == "ushort" ? int(sizeof(unsigned short)) : int(sizeof(int)));
    }
    if (line.find("property list") != std::string::npos && line.find("texcoord") != std::string::npos)
    {
      sscanf(line.c_str(), "%s %s %s %s %s", char1, char2, char3, char4, char5);
      std::string type1(char3);
      std::string type2(char4);
      uv_order_size     = type1 == "uchar" ? int(sizeof(unsigned char)) : (type1 == "ushort" ? int(sizeof(unsigned short)) : int(sizeof(int)));
      uv_size = type2 == "float" ? int(sizeof(float)) : int(sizeof(double));
    }
    if (line.find("property int texnumber") != std::string::npos)
    {
      texnumber_size = 4;
    }
  }
  if (pos_offset == -1)
  {
    std::cerr << "error, mesh file does not contain x, y, z data" << std::endl;
    return false;
  }

  mesh.vertices().resize(number_of_vertices);
  std::vector<unsigned char> vertices(row_size);
  std::cout << "row size: " << row_size << std::endl;
  for (unsigned int i = 0; i<number_of_vertices; i++)
  {
    input.read((char *)&vertices[0], row_size);
    if (pos_is_float)
    {
      Eigen::Vector3f e = (Eigen::Vector3f &)vertices[pos_offset];
      mesh.vertices()[i] = Eigen::Vector3d(e[0], e[1], e[2]);
    }
    else
    {
      mesh.vertices()[i] = (Eigen::Vector3d &)vertices[pos_offset];
    }
  }
  row_size = order_size + 3*vertex_index_size + uv_order_size + 6*uv_size + texnumber_size;
  std::vector<unsigned char> triangles(number_of_faces * row_size);
  input.read((char *)&triangles[0], triangles.size());

  mesh.indexList().resize(number_of_faces);
  if (uv_size > 0)
  {
    mesh.uvList().resize(number_of_faces);
  }
  for (unsigned int i = 0; i < number_of_faces; i++)
  {
    for (int j = 0; j<3; j++)
    {
      if (vertex_index_size == int(sizeof(unsigned char))) 
      {
        unsigned char index = (unsigned char &)triangles[row_size*i + order_size + j*vertex_index_size];
        mesh.indexList()[i][j] = int(index);
      }
      else if (vertex_index_size == int(sizeof(unsigned short))) 
      {
        unsigned short index = (unsigned short &)triangles[row_size*i + order_size + j*vertex_index_size];
        mesh.indexList()[i][j] = int(index);
      }
      else if (vertex_index_size == int(sizeof(int))) 
      {
        mesh.indexList()[i][j] = (int &)triangles[row_size*i + order_size + j*vertex_index_size];
      }
    }
    if (uv_size > 0)
    {
      for (int j = 0; j<3; j++)
      {
        if (uv_size == 4)
        {
          float u = (float &)triangles[row_size*i + order_size + 3*vertex_index_size + uv_order_size + 2*j*uv_size];
          float v = (float &)triangles[row_size*i + order_size + 3*vertex_index_size + uv_order_size + (2*j + 1)*uv_size];
          mesh.uvList()[i][j] = std::complex<float>(u, v);
        }
        else // uv_size == 8
        {
          double u = (double &)triangles[row_size*i + order_size + 3*vertex_index_size + uv_order_size + 2*j*uv_size];
          double v = (double &)triangles[row_size*i + order_size + 3*vertex_index_size + uv_order_size + (2*j + 1)*uv_size];
          mesh.uvList()[i][j] = std::complex<float>((float)u, (float)v);
        }      
      }
    }
  }
  std::cout << "reading from " << file << ", " << mesh.indexList().size() << " triangles." << std::endl;
  return true;
}

bool convertCloud(const std::string &in_name, const std::string &out_name,
                  std::function<void(Eigen::Vector3d &start, Eigen::Vector3d &ends, double &time, RGBA &colour, uint8_t &classification, uint16_t &branch_id)> apply)
{
  std::ofstream ofs;
  if (!writeRayCloudChunkStart(out_name, ofs, true, true))
  {
    return false;
  }
  std::vector<char> buffer;

  bool has_warned = false;
  // run the function 'apply' on each ray as it is read in, and write it out, one chunk at a time
  auto applyToChunk = [&apply, &buffer, &ofs, &has_warned](std::vector<Eigen::Vector3d> &starts, std::vector<Eigen::Vector3d> &ends,
                                              std::vector<double> &times, std::vector<ray::RGBA> &colours,
                                              std::vector<uint8_t> &classifications, std::vector<uint16_t> &branch_ids) {
    for (size_t i = 0; i < ends.size(); i++)
    {
      apply(starts[i], ends[i], times[i], colours[i], classifications[i], branch_ids[i]);
    }
    ray::writeRayCloudChunk(ofs, buffer, starts, ends, times, colours, classifications, branch_ids, has_warned);
  };
  if (!ray::readPly(in_name, true, applyToChunk, 0))
  {
    return false;
  }
  
  // This needs to know the vertex size to finish correctly.
  size_t vertex_byte_size = 0;
#if RAYLIB_DOUBLE_RAYS
  vertex_byte_size += sizeof(double) * 3;
#else
  vertex_byte_size += sizeof(float) * 3;
#endif
  vertex_byte_size += sizeof(double); // time
  vertex_byte_size += sizeof(float) * 3; // ray
  vertex_byte_size += sizeof(RGBA);
  vertex_byte_size += sizeof(uint8_t); // classification
  vertex_byte_size += sizeof(uint16_t); // branch_id
  
  ray::writeRayCloudChunkEnd(ofs, vertex_byte_size);
  return true;
}

}  // namespace ray
